#!/usr/bin/env python3

# =====================================
# Author: Samuel Law
# TODO:
#   flesh out a way to set up axis more effectiently
#   handle arcs
#   fix diagonal moves
#   fix none clearings
# BUG:
#   n/a
# =====================================


from collections import deque
from itertools import groupby


# declare enums to help with readability
code, kind, lnum = 0, 1, 2


class rs274Plotter():
    """
    class that uses parsed gcode objects generated by
    gparse.rs274Parser module to create 3D backplots
    """

    def __init__(self):

        # codes you want to catch
        # and the function you want to handle them
        # "<code> func(<code>)"
        self.func_dict = {
            "G00": self.linear,
            "G0": self.linear,
            "G01": self.linear,
            "G1": self.linear,
            "G2": self.arc,
            "G02": self.arc,
            "G3": self.arc,
            "G03": self.arc,
            "I": self.arc,
            "J": self.arc,
            "K": self.arc,
            "R": self.arc,
            "P": self.arc
        }

    def load_gcode(self, parsed_gcode):
        """gathers all code from gcode
        parsed using gparse.rs_274.rs274Parser"""

        if hasattr(self, 'gcode'):
            raise AttributeError(
                "Self already has gcode object"
                "Call clear_gcode before attempting to load new gcode."
            )

        # scrape away all none code
        self.gcode = [x for x in parsed_gcode if x[1] == 'code']
        # make sure all cmds are uppercase
        for x in self.gcode:
            x[0] = x[0].upper()

    def clear_gcode(self):
        """clears old gcode out of memory"""
        if hasattr(self, 'gcode'):
            del self.gcode

    def group_gcode_by_line(self, gcode):
        """groups the code by line"""
        lines_of_code = []
        for _, group in groupby(gcode, lambda g: g[lnum]):
            lines_of_code.append(list(group))
        return lines_of_code

    # FIX THIS ONE UP A BIT
    def setup_axis(self, *, linear: dict, arc: dict):
        """setup the axis to call the correct function"""

        # define containers
        self.xyz_points = []  # holds the 2D array of xyz points
        self.coordinate_dict = {}  # holds the coordinates when found
        self.coordinate_deque = deque()  # unique absolut coordinate set

        for absolute, incrimental in linear.items():
            # add absolute items to func_dict along with function
            self.func_dict[absolute] = self.lin_absolute
            self.coordinate_dict[absolute] = [None]  # <- "python pointer made"
            self.coordinate_deque.append(absolute)
            if incrimental:
                # add corresponding incremental axis definition
                self.func_dict[incrimental] = self.lin_incremental
                self.coordinate_dict[incrimental] = \
                    self.coordinate_dict[absolute]  # <- python pointer use"

    def generate_points(self):
        self.gcode = self.group_gcode_by_line(self.gcode)
        for line in self.gcode:
            gcode_iter = iter(line)
            g = next(gcode_iter)
            try:
                while gcode_iter:
                    # calls the appropriate action based on
                    # next value yielded by the iter
                    g = self.func_dict.get(
                        g[0], self.func_dict.get(
                            g[0][0], self.next))(gcode_iter, g)
            except StopIteration:
                self.add_point()
        self.xyz_points = [p for p in self.xyz_points if None not in p]
        return self.xyz_points

    #    _____                   _   ______
    #   / ____|                 | | |  ____|
    #  | |       _ __ ___     __| | | |__     _   _   _ __     ___   ___
    #  | |      | '_ ` _ \   / _` | |  __|   | | | | | '_ \   / __| / __|
    #  | |____  | | | | | | | (_| | | |      | |_| | | | | | | (__  \__ \
    #   \_____| |_| |_| |_|  \__,_| |_|       \__,_| |_| |_|  \___| |___/

    def linear(self, gcode_iter, g):
        """handles linear modal cmds like G00 and G01"""
        self.moves = 'linear'
        return next(gcode_iter)

    def lin_absolute(self, gcode_iter, g):
        """handles linear absolute cmds like X-0.5"""
        self.coordinate_dict[g[code][0]][0] = float(g[code][1:])
        return next(gcode_iter)

    def lin_incremental(self, gcode_iter, g):
        """handles linear incremental cmds like U-0.5"""
        self.coordinate_dict[g[code][0]][0] += float(g[code][1:])
        return next(gcode_iter)

    # NOT IMPLEMENTED
    def arc(self, gcode_iter, g):
        """handles arc cmds which are by definition non modal"""
        self.moves = 'arc'
        return next(gcode_iter)

    def next(self, iterable, *_):
        return next(iterable)

    def add_point(self):
        """adds xyz_points to be plotted"""
        self.xyz_points.append(
            [self.coordinate_dict[x][0] for x in self.coordinate_deque]
        )
